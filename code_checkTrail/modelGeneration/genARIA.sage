import os
localdir = os.path.dirname(__file__)
if localdir == "":
	localdir = "."
os.chdir(localdir)

load("MILP_function.sage")
load("divtrail.sage")
import sys, getopt

def genARIAModel(rMax, sboxModel="Simple", linModel="Simple", lastLin=True, startingRound=1, firstSbox=True):
	"""
	Generate the model for ARIA over #rMax rounds
	#lastLin defines if the linear layer is applied on the last round
	#startingRound defines the index of the first round (changes the Sbox layer)
	#firstSbox defines if the first Sbox layer is applied

	#From the specifiation, the first round is of index 1 (not 0)
	#"LS= (S1; S2; S1-1; S2-1)."
	#"In each odd round,the substitutionlayer is (LS; LS; LS; LS)"
	#From Figure 3, starts with Type 1 (LS,LS,LS,LS)


	The #sboxModel parameter defines how the Sbox is modelized :
	- "QM" use the Quin-McCluskey algorithm as in Abdelkhalek,Sasaki,Todo,Tolba,Youssef
	- "Simple" use the simplified constraint with PWL

	The #linModel parameter defines how the linear layer is modelized :
	- "CX" modelize the linear layer using the classical copy+xor technique
	- "Simple" modelize the linear layer with the simplified constraint w(x) = w(y)
	"""

	if sboxModel not in ["Simple","QM"]:
		print("Unknown value for the sboxModel parameter, default to Simple")
		sboxModel = "Simple"

	if linModel not in ["QM", "CX", "Simple"]:
		print("Unknown value for the linModel parameter, default to Simple")
		linModel = "Simple"

	blockSize = 128
	nbSbox = 16
	sboxSize = 8

	# S1 = [0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
	# 	  0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
	# 	  0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
	# 	  0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
	# 	  0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
	# 	  0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
	# 	  0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
	# 	  0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
	# 	  0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
	# 	  0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
	# 	  0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
	# 	  0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
	# 	  0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
	# 	  0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
	# 	  0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
	# 	  0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16]

	# invS1 = [0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
	# 		 0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
	# 		 0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
	# 		 0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
	# 		 0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
	# 		 0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
	# 		 0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
	# 		 0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
	# 		 0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
	# 		 0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
	# 		 0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
	# 		 0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
	# 		 0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
	# 		 0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
	# 		 0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
	# 		 0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D]

	# S2 = [0xE2,0x4E,0x54,0xFC,0x94,0xC2,0x4A,0xCC,0x62,0x0D,0x6A,0x46,0x3C,0x4D,0x8B,0xD1,
	# 	  0x5E,0xFA,0x64,0xCB,0xB4,0x97,0xBE,0x2B,0xBC,0x77,0x2E,0x03,0xD3,0x19,0x59,0xC1,
	# 	  0x1D,0x06,0x41,0x6B,0x55,0xF0,0x99,0x69,0xEA,0x9C,0x18,0xAE,0x63,0xDF,0xE7,0xBB,
	# 	  0x00,0x73,0x66,0xFB,0x96,0x4C,0x85,0xE4,0x3A,0x09,0x45,0xAA,0x0F,0xEE,0x10,0xEB,
	# 	  0x2D,0x7F,0xF4,0x29,0xAC,0xCF,0xAD,0x91,0x8D,0x78,0xC8,0x95,0xF9,0x2F,0xCE,0xCD,
	# 	  0x08,0x7A,0x88,0x38,0x5C,0x83,0x2A,0x28,0x47,0xDB,0xB8,0xC7,0x93,0xA4,0x12,0x53,
	# 	  0xFF,0x87,0x0E,0x31,0x36,0x21,0x58,0x48,0x01,0x8E,0x37,0x74,0x32,0xCA,0xE9,0xB1,
	# 	  0xB7,0xAB,0x0C,0xD7,0xC4,0x56,0x42,0x26,0x07,0x98,0x60,0xD9,0xB6,0xB9,0x11,0x40,
	# 	  0xEC,0x20,0x8C,0xBD,0xA0,0xC9,0x84,0x04,0x49,0x23,0xF1,0x4F,0x50,0x1F,0x13,0xDC,
	# 	  0xD8,0xC0,0x9E,0x57,0xE3,0xC3,0x7B,0x65,0x3B,0x02,0x8F,0x3E,0xE8,0x25,0x92,0xE5,
	# 	  0x15,0xDD,0xFD,0x17,0xA9,0xBF,0xD4,0x9A,0x7E,0xC5,0x39,0x67,0xFE,0x76,0x9D,0x43,
	# 	  0xA7,0xE1,0xD0,0xF5,0x68,0xF2,0x1B,0x34,0x70,0x05,0xA3,0x8A,0xD5,0x79,0x86,0xA8,
	# 	  0x30,0xC6,0x51,0x4B,0x1E,0xA6,0x27,0xF6,0x35,0xD2,0x6E,0x24,0x16,0x82,0x5F,0xDA,
	# 	  0xE6,0x75,0xA2,0xEF,0x2C,0xB2,0x1C,0x9F,0x5D,0x6F,0x80,0x0A,0x72,0x44,0x9B,0x6C,
	# 	  0x90,0x0B,0x5B,0x33,0x7D,0x5A,0x52,0xF3,0x61,0xA1,0xF7,0xB0,0xD6,0x3F,0x7C,0x6D,
	# 	  0xED,0x14,0xE0,0xA5,0x3D,0x22,0xB3,0xF8,0x89,0xDE,0x71,0x1A,0xAF,0xBA,0xB5,0x81]

	# invS2 = [0x30,0x68,0x99,0x1B,0x87,0xB9,0x21,0x78,0x50,0x39,0xDB,0xE1,0x72,0x09,0x62,0x3C,
	# 		 0x3E,0x7E,0x5E,0x8E,0xF1,0xA0,0xCC,0xA3,0x2A,0x1D,0xFB,0xB6,0xD6,0x20,0xC4,0x8D,
	# 		 0x81,0x65,0xF5,0x89,0xCB,0x9D,0x77,0xC6,0x57,0x43,0x56,0x17,0xD4,0x40,0x1A,0x4D,
	# 		 0xC0,0x63,0x6C,0xE3,0xB7,0xC8,0x64,0x6A,0x53,0xAA,0x38,0x98,0x0C,0xF4,0x9B,0xED,
	# 		 0x7F,0x22,0x76,0xAF,0xDD,0x3A,0x0B,0x58,0x67,0x88,0x06,0xC3,0x35,0x0D,0x01,0x8B,
	# 		 0x8C,0xC2,0xE6,0x5F,0x02,0x24,0x75,0x93,0x66,0x1E,0xE5,0xE2,0x54,0xD8,0x10,0xCE,
	# 		 0x7A,0xE8,0x08,0x2C,0x12,0x97,0x32,0xAB,0xB4,0x27,0x0A,0x23,0xDF,0xEF,0xCA,0xD9,
	# 		 0xB8,0xFA,0xDC,0x31,0x6B,0xD1,0xAD,0x19,0x49,0xBD,0x51,0x96,0xEE,0xE4,0xA8,0x41,
	# 		 0xDA,0xFF,0xCD,0x55,0x86,0x36,0xBE,0x61,0x52,0xF8,0xBB,0x0E,0x82,0x48,0x69,0x9A,
	# 		 0xE0,0x47,0x9E,0x5C,0x04,0x4B,0x34,0x15,0x79,0x26,0xA7,0xDE,0x29,0xAE,0x92,0xD7,
	# 		 0x84,0xE9,0xD2,0xBA,0x5D,0xF3,0xC5,0xB0,0xBF,0xA4,0x3B,0x71,0x44,0x46,0x2B,0xFC,
	# 		 0xEB,0x6F,0xD5,0xF6,0x14,0xFE,0x7C,0x70,0x5A,0x7D,0xFD,0x2F,0x18,0x83,0x16,0xA5,
	# 		 0x91,0x1F,0x05,0x95,0x74,0xA9,0xC1,0x5B,0x4A,0x85,0x6D,0x13,0x07,0x4F,0x4E,0x45,
	# 		 0xB2,0x0F,0xC9,0x1C,0xA6,0xBC,0xEC,0x73,0x90,0x7B,0xCF,0x59,0x8F,0xA1,0xF9,0x2D,
	# 		 0xF2,0xB1,0x00,0x94,0x37,0x9F,0xD0,0x2E,0x9C,0x6E,0x28,0x3F,0x80,0xF0,0x3D,0xD3,
	# 		 0x25,0x8A,0xB5,0xE7,0x42,0xB3,0xC7,0xEA,0xF7,0x4C,0x11,0x33,0x03,0xA2,0xAC,0x60]
	
	fullM = None
	if linModel == "CX":
		i = identity_matrix(GF(2),8,8)
		z = zero_matrix(GF(2),8,8)
		fullM = block_matrix([[z,z,z,i,i,z,i,z,i,i,z,z,z,i,i,z],
							  [z,z,i,z,z,i,z,i,i,i,z,z,i,z,z,i],
							  [z,i,z,z,i,z,i,z,z,z,i,i,i,z,z,i],
							  [i,z,z,z,z,i,z,i,z,z,i,i,z,i,i,z],
							  [i,z,i,z,z,i,z,z,i,z,z,i,z,z,i,i],
							  [z,i,z,i,i,z,z,z,z,i,i,z,z,z,i,i],
							  [i,z,i,z,z,z,z,i,z,i,i,z,i,i,z,z],
							  [z,i,z,i,z,z,i,z,i,z,z,i,i,i,z,z],
							  [i,i,z,z,i,z,z,i,z,z,i,z,z,i,z,i],
							  [i,i,z,z,z,i,i,z,z,z,z,i,i,z,i,z],
							  [z,z,i,i,z,i,i,z,i,z,z,z,z,i,z,i],
							  [z,z,i,i,i,z,z,i,z,i,z,z,i,z,i,z],
							  [z,i,i,z,z,z,i,i,z,i,z,i,i,z,z,z],
							  [i,z,z,i,z,z,i,i,i,z,i,z,z,i,z,z],
							  [i,z,z,i,i,i,z,z,z,i,z,i,z,z,i,z],
							  [z,i,i,z,i,i,z,z,i,z,i,z,z,z,z,i]], subdivide=False)

	#--- Precomputations ---

	#Compute the ANF of S
	# (BPR, anfS) = SBOX_ANF(S)
	#Generate the inequalities for S
	# divTableS = SboxDivTrailTable(anfS)
	divTableS1 = load("divTableARIAS1.sobj")
	divTableinvS1 = load("divTableARIAinvS1.sobj")
	divTableS2 = load("divTableARIAS2.sobj")
	divTableinvS2 = load("divTableARIAinvS2.sobj")
	
	ineqS1 = None
	ineqinvS1 = None
	ineqS2 = None
	ineqinvS2 = None

	outLBS1 = None
	outLBinvS1 = None
	outLBS2 = None
	outLBinvS2 = None

	ineqMC = None

	if sboxModel == "QM":
		ineqS1 = load("ineqARIAS1Sbox.sobj")
		ineqinvS1 = load("ineqARIAinvS1Sbox.sobj")
		ineqS2 = load("ineqARIAS2Sbox.sobj")
		ineqinvS2 = load("ineqARIAinvS2Sbox.sobj")

	elif sboxModel == "Simple":
		#Generate the lower bounds for the output weight of S
		outLBS1 = computeLBWeightSbox(divTableS1,sboxSize)
		outLBinvS1 = computeLBWeightSbox(divTableinvS1,sboxSize)
		outLBS2 = computeLBWeightSbox(divTableS2,sboxSize)
		outLBinvS2 = computeLBWeightSbox(divTableinvS2,sboxSize)

	if linModel == "QM":
		ineqMC = load("ineqARIAMCLbox")


	#--- Model generation ---

	#Create the model
	modelName = "ARIA_"+str(rMax)+"r_"+sboxModel+"_"+linModel
	if lastLin:
		modelName += "_lastLin"
	if not firstSbox:
		modelName += "_noFirstSbox"
	modelName += "_start"+str(startingRound)
	m = Model(modelName)

	#Create the variables
	x = []
	y = []
	z = []
	if lastLin:
		#x[r] --S--> y[r] --MC--> x[r+1]
		if firstSbox:
			x = [[m.addVar(vtype=GRB.BINARY, name="x"+str(r)+"_"+str(j)) for j in range(blockSize)] for r in range(rMax+1)]
		else: #empty list for first round
			x = [[]] + [[m.addVar(vtype=GRB.BINARY, name="x"+str(r)+"_"+str(j)) for j in range(blockSize)] for r in range(1,rMax+1)]

		y = [[m.addVar(vtype=GRB.BINARY, name="y"+str(r)+"_"+str(j)) for j in range(blockSize)] for r in range(rMax)]
	else:
		#x[r] --S--> y[r] --MC--> x[r+1]
		#No MC on last round so stops at y[rMax-1]
		if firstSbox:
			x = [[m.addVar(vtype=GRB.BINARY, name="x"+str(r)+"_"+str(j)) for j in range(blockSize)] for r in range(rMax)]
		else: #empty list for first round
			x = [[]] + [[m.addVar(vtype=GRB.BINARY, name="x"+str(r)+"_"+str(j)) for j in range(blockSize)] for r in range(1,rMax)]

		y = [[m.addVar(vtype=GRB.BINARY, name="y"+str(r)+"_"+str(j)) for j in range(blockSize)] for r in range(rMax)]

	m.update()

	#Check if we need the first Sbox layer
	roundFirstSbox = 0
	if not firstSbox:
		roundFirstSbox = 1

	#Modelize the Sbox layers
	#y[r] = S(x[r])
	if sboxModel == "QM":
		for r in range(roundFirstSbox,rMax):
			if (r+startingRound)%2 == 0:
				#Sbox layer invS1 invS2 S1 S2 ...
				for i in range(0,nbSbox,4):
					#invS1
					invar = [x[r][sboxSize*i + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*i + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqinvS1, invar, outvar)
					#invS2
					invar = [x[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqinvS2, invar, outvar)
					#S1
					invar = [x[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqS1, invar, outvar)
					#S2
					invar = [x[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqS2, invar, outvar)
			else:
				#Sbox layer S1 S2 invS1 invS2
				for i in range(0,nbSbox,4):
					#S1
					invar = [x[r][sboxSize*i + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*i + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqS1, invar, outvar)
					#S2
					invar = [x[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqS2, invar, outvar)
					#invS1
					invar = [x[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqinvS1, invar, outvar)
					#invS2
					invar = [x[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					addSboxConstr(m, ineqinvS2, invar, outvar)

	elif sboxModel == "Simple":
		for r in range(roundFirstSbox,rMax):
			if (r+startingRound)%2 == 0:
				#Sbox layer invS1 invS2 S1 S2 ...
				for i in range(0,nbSbox,4):
					#invS1
					invar = [x[r][sboxSize*i + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*i + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBinvS1, boundSuffix="s"+str(r)+"_"+str(i))
					#invS2
					invar = [x[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBinvS2, boundSuffix="s"+str(r)+"_"+str((i+1)))
					#S1
					invar = [x[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBS1, boundSuffix="s"+str(r)+"_"+str((i+2)))
					#S2
					invar = [x[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBS2, boundSuffix="s"+str(r)+"_"+str((i+3)))
			else:
				#Sbox layer S1 S2 invS1 invS2
				for i in range(0,nbSbox,4):
					#S1
					invar = [x[r][sboxSize*i + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*i + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBS1, boundSuffix="s"+str(r)+"_"+str(i))
					#S2
					invar = [x[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+1) + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBS2, boundSuffix="s"+str(r)+"_"+str((i+1)))
					#invS1
					invar = [x[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+2) + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBinvS1, boundSuffix="s"+str(r)+"_"+str((i+2)))
					#invS2
					invar = [x[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					outvar = [y[r][sboxSize*(i+3) + j] for j in range(sboxSize)]
					addSimplifiedSboxConstr(m,invar, outvar, outLBinvS2, boundSuffix="s"+str(r)+"_"+str((i+3)))

	#Check if we need the last linear layer
	roundLastLin = rMax
	if not lastLin:
		roundLastLin = rMax-1

	#Modelize the linear layer
	#x[r+1] = MC(y[r])
	if linModel == "CX":
		#Modelize MC with the Copy+XOR technique
		for r in range(roundLastLin):
			addLinearConstrCX(m, y[r], x[r+1], fullM)

	elif linModel == "Simple":
		for r in range(roundLastLin):
			addSimplifiedLinearConstr(m, y[r], x[r+1])

	elif linModel == "QM":
		for r in range(roundLastLin):
			for offset in range(8):
				invar  = [y[r][offset + i*8] for i in range(16)]
				outvar = [x[r+1][offset + i*8] for i in range(16)]
				addSboxConstr(m,ineqMC,invar,outvar)


	m.update()
	m.write("./../models/"+modelName+".mps")


if __name__ == "__main__":
	rMax = 1
	sboxModel = "Simple"
	linModel = "Simple"
	lastLin = True
	startingRound = 1
	firstSbox = True
	try:
		opts, args = getopt.getopt(sys.argv[1:], "hr:s:m:", ["lastLin=","startingRound=","firstSbox="])
	except getopt.GetoptError:
		print("genARIA.sage -r <rMax> -s <sboxModel> -m <linModel> --lastLin <lastLin> --startingRound <startingRound> --firstSbox <firstSbox>")
		print("<rMax> is the number of rounds")
		print("<sboxModel> is the technique used for the modelization of the Sbox")
		print("           Possible options : QM Simple")
		print("<linModel> is the technique used for the modelization of MC")
		print("           Possible options : QM CX Simple")
		print("<lastLin> set if the last linear layer is applied")
		print("          Possible options : True False")
		print("<startingRound> defines the index of the first round (as it changes the sbox layers)")
		print("<firstSbox> set if the first sbox layer is applied")
		print("          Possible options : True False")
		sys.exit(2)
	for opt, arg in opts:
		if opt == "-h":
			print("genARIA.sage -r <rMax> -s <sboxModel> -m <linModel> --lastLin <lastLin> --startingRound <startingRound>")
			print("<rMax> is the number of rounds")
			print("<sboxModel> is the technique used for the modelization of the Sbox")
			print("           Possible options : QM Simple")
			print("<linModel> is the technique used for the modelization of MC")
			print("           Possible options : QM CX Simple")
			print("<lastLin> set if the last linear layer is applied")
			print("          Possible options : True False")
			print("<startingRound> defines the index of the first round (as it changes the sbox layers)")
			print("<firstSbox> set if the first sbox layer is applied")
			print("          Possible options : True False")
			sys.exit()
		elif opt == "-r":
			rMax = int(arg)
		elif opt == "-s":
			sboxModel = arg
		elif opt == "-m":
			linModel = arg
		elif opt == "--lastLin":
			if arg == "True":
				lastLin = True
			elif arg == "False":
				lastLin = False
		elif opt == "--startingRound":
			startingRound = int(arg)
		elif opt == "--firstSbox":
			if arg == "True":
				firstSbox = True
			elif arg == "False":
				firstSbox = False

	genARIAModel(rMax,sboxModel,linModel,lastLin,startingRound,firstSbox)




